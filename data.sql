insert into t_user(id, user_name, password, role)
values (19029306617364480, 'admin1', '$2a$10$Xr.zl8/STE7VKD5B0meYUOIhFLNn6DPGzH8y86J1eLauhA5FWtnEe', 3);
INSERT INTO `t_choose`(`id`, `title`, `choice0`, `choice1`, `choice2`, `choice3`, `key_answer`)
VALUES (11, '编译程序绝大多数时间花在什么上', '词法分析', '语法分析', '语义分析', '表格管理', '表格管理'),
       (12,
        '汇编程序是将___ 翻译成__;编译程序是将____翻译成_____。①高级语言②汇编语言③机器语言④高级语言或汇编语言⑤汇编语言或机器语言',
        '①③①⑤', '②③①⑤', '④③①③', '②③①③', '②③①⑤'),
       (13, '给定文法G[A]：A→bA|cc ____是该文法的句子。', 'bcbc', 'bcbcc', 'bccbcc', 'bbbcc', 'bbbcc'),
       (14, '已知语言{anbnci | n>=1,i>=0 }，则下述文法中，______可以产生该语言。', 'S→AB, A→aAb|ab, B→cB|c',
        'S→aAb, A→aBb, B→cB|c', 'S→AB, A→aAb|ab, B→cB|ε', 'S→aSb|A, A→bAc|c', 'S→AB, A→aAb|ab, B→cB|ε'),
       (15, '在通常的语法分析方法中，___特别适用于表达式的分析。', 'LR(1)分析法', 'LL(1)分析法', '递归下降分析法',
        '算符优先分析法', '算符优先分析法'),
       (16, '在DFA的最小化过程中，初始应该把集合根据____划分子集。', '初态和非初态', '终态和非终态', '是否含有ε出边',
        '是否有出边', '终态和非终态'),
       (17, '基本块内的优化为___', '代码外提，删除归纳变量', '强度削弱，代码外提', '删除多余运算，删除无用赋值',
        '循环展开，循环合并', '删除多余运算，删除无用赋值'),
       (18, '若文法G定义的语言是无限集，则文法必然是___', '递归的', '二义性的', '前后文无关的', '无二义性的', 'A递归的'),
       (19, '下列____优化方法不是针对循环优化进行的。', '强度削弱', '删除归纳变量', '删除公共子表达式', '代码外提',
        '删除公共子表达式'),
       (20, '错误的局部化是指____', '把错误理解成局部的错误', '对错误在局部范围内进行纠正',
        '当发现错误时，跳过错误所在的语法单位继续分析下去', '当发现错误时立即停止编译，待用户改正错误后再继续编译',
        '当发现错误时，跳过错误所在的语法单位继续分析下去');

INSERT INTO `t_fill`(`id`, `title`, `key_answer`)
VALUES (1, 'PL0语言编译后的中间代码', 'P-Code'),
       (2, 'java通过什么实现跨平台', 'JVM'),
       (3, '判断句子是否符合某个给定的上下文无关文法的', '语法分析'),
       (4, 'JIT什么意思', '即时编译'),
       (5, 'FSM是什么', '有限状态自动机'),
       (6, '状态不确定的自动机的哪个', 'NFA'),
       (7, '词法分析后是什么', '语法分析'),
       (8, 'java编译后生成什么', '字节码文件');

INSERT INTO t_config(id, lexer_deadline, lexer_id, last_update_user_id)
values (1, '20250101000000', 1, 0);

insert into `t_lexer`(id, language, comp_language, description, commit_num, pass_num)
values (1, "C++", "PL0", "描述", 1, 0),
       (2, "C++", "Cangjie", "描述。。。", 1, 0);


insert into `t_lexer_testcase`(id, lexer_id, terminal_input, terminal_output)
values (1,
        1,
        'test1',
        'test2'),
       (6,
        2,
        'test8',
        'test9');



insert into `t_method_body`(id, method_id, description, input, output, in_param, out_param, global_var, changed_global,
                            pre_method, body)
values (31231412312, 3, "获取一个字符，返回值字符的ASCII值", "int a = 1;", "", "", "105", "", "", "", "int getch(){}");


insert into `t_method_testcase`(id, method_id, pre_code, terminal_input, terminal_output)
values (3116114,
        3,
        '#include<iostream>\n#include<cstdio>\nusing namespace std;\nint getch();\nint main(){\n    int output = getch();\n    cout<<endl;\n    cout<<"fhj……*……*（w4oqqh53fowhgfowhfoa…^hjf￥……oahwgofahwjioefhjo"<<endl;\n   cout<<output<<endl;\n    cout<<"fhj……*……*（w4oqqh53fowhgfowhfoa…^hjf￥……oahwgofahwjioefhjo"<<endl;\n}\n',
        'int i = 8;',
        '\nfhj……*……*（w4oqqh53fowhgfowhfoa…^hjf￥……oahwgofahwjioefhjo\n105\nfhj……*……*（w4oqqh53fowhgfowhfoa…^hjf￥……oahwgofahwjioefhjo\n');



INSERT INTO `t_method_name`(`id`, `language`, `comp_language`, `name`, `level`, `commit_num`, `pass_num`)
VALUES (1, 'c', 'PL0', 'void error(int n)', 0, 4234242, 3242),
       (2, 'c', 'PL0', 'int getsym()', '2', 4244234242, 3242342),
       (3, 'c', 'PL0', 'int getch()', '1', 423214242, 32342),
       (4, 'c', 'PL0', 'void init()', '1', 421134242, 113242),
       (5, 'c', 'PL0', 'int gen(enums fct, int y, int z)', '2', 411234242, 31111242),
       (6, 'c', 'PL0', 'int test(bool * sl, bool * s2, int n)', '1', 421134242, 321134242),
       (7, 'c', 'PL0', 'int inset(int e, bool * s)', '1', 421134242, 321134242),
       (8, 'c', 'PL0', 'int addset(bool * sr, bool * sl, bool * s2, int n)', '1', 421134242, 321134242),
       (9, 'c', 'PL0', 'int subset(bool * sr, bool * sl, bool * s2, int n)', '1', 421134242, 321134242),
       (10, 'c', 'PL0', 'int mulset(bool * sr, bool * sl, bool * s2, int n)', '1', 421134242, 321134242),
       (11, 'c', 'PL0', 'int block(int lev, int tx, bool * fsys)', '1', 421134242, 321134242),
       (12, 'c', 'PL0', 'void interpret()', '1', 421134242, 321134242),
       (13, 'c', 'PL0', 'int factor(bool * fsys, int * ptx, int lev)', '1', 421134242, 321134242),
       (14, 'c', 'PL0', 'int term(bool * fsys, int * ptx, int lev)', '1', 421134242, 321134242),
       (15, 'c', 'PL0', 'int condition(bool * fsys, int * ptx, int lev)', '1', 421134242, 321134242),
       (16, 'c', 'PL0', 'int expression(bool * fsys, int * ptx, int lev)', '1', 421134242, 321134242),
       (17, 'c', 'PL0', 'int statement(bool * fsys, int * ptx, int lev)', '1', 421134242, 321134242),
       (18, 'c', 'PL0', 'void listcode(int cx0)', '1', 421134242, 321134242),
       (19, 'c', 'PL0', 'int vardeclaration(int * ptx, int lev, int * pdx)', '1', 421134242, 321134242),
       (20, 'c', 'PL0', 'int constdeclaration(int * ptx, int lev, int * pdx)', '1', 421134242, 321134242),
       (21, 'c', 'PL0', 'int position(char * idt, int tx)', '1', 421134242, 321134242),
       (22, 'c', 'PL0', 'void enter(enums object k, int * ptx, int lev, int * pdx)', '1', 421134242, 321134242),
       (23, 'c', 'PL0', 'int common(int l, int * s, int b)', '1', 421134242, 321134242);



INSERT INTO `t_ai_q_a`
VALUES (454295264739274752,
        '问题9：能否教我用C语言写一个词法分析器中的函数“isDelimiter(token):判断一个单词是否是分隔符”？',
        0x1F8B08000000000000FF7D534B6F125114DEDF5F711317D4A4DA7D352686C6A41B373571E382E970716E3A0E661EB2304D8686D4B1A5A216B5528AF401C1060A89A6451EF6C774EE9D61D5BFE0B95C2062897775E69CEF7CE7F50DEBEF069973966BFADDCA95BBC18AB568D86C8435D76F37AE7B59BF0DC629F33607857C50AF4A1CDF6B06DF3BBCDCBB72D3CC3B0F0F6B1012F67E29EC5783C65B20F2DBDB83832340B2B352F0AE45AD25A2D317D426267BD3E79F5A412113F5BBC741397DDD2B20148BC554748B1AAAEEC409BE6FD9F1D56452BFAB3DC00B0B389134B1F89CC7B6E990799C50748B200491478EA1DA3469603B89558DA86B9826B0025F6BC4C0D402333E2E8B0403FEAB8F3955534C09BD8D5F230C0F189F129CA2BA8E1D8BE0872BD1E565FC4AD11D624D55B03532BB8620B152D456353C37C52C9EAA582412591455565E2A2A990AE0C8335BC69E28ABFF460C19794C523A356EE499321A554C932ACF093689ED98C604259E740DD7776F12889384E2E8F6E22CE470C512BA8ED6C57910026DF8ED2DB82ADC4E9E4E6A847B1FFC6EDDEF5F06F99A1CFE8EE82CE8EEF252861F54F8B1CBBF5558E30BA80452875B656E4FA8ADBAC14BC5B103F867CA8AEF1C858759B0B9F77924B12922D905F3BE4A65859779408951C12B484E3A6173545EE871AC6551FF7D15D2046C98331C1ADC0885CD0BFEA3C63339315EB10E14FEEF6DA8C372A7721ABFB3F9FF5ED9C7ECA4D7C9A483A21B56D39281EFFF6427051863D2901842FE5FE55F7CE76C04BEE8B2AD32F35A37360BED885EFF009C2827EAC1030000,
        '2024-06-07 14:47:12', '2024-06-07 14:47:12', 0),
       (454543139868061696, '问题1：能否教我用C语言写一个词法分析器中的函数“isKeyword(token):判断一个单词是否是关键字”？',
        0x1F8B08000000000000FF85545B4F1341147EDF5F312931B46A80F7AA2FEA9351132F3106892CDB693B61D9217B112F212988D80A142FD40B1414B58418E9361A4DA55C7E8C7B699FF80B9E99E96EB78DCA3ECCCC9E39E73BB76F8EBBFFCA9FFBE92EDB4EA3F23B374B8C4BF8C114D55371938E632DE13EDDF74A357F75CE5FABC2EABDB5BD4F39EF7DC56FBC73ABAB2071974A4D7BE9682FCFF58FF60AA0E23EDF82B569EF34B773A0E21CAEFBA577EECE1B2FFFDA7DF2BDB5528533F8028F4E7D0134FD95EDF342DBAD6EF8C55AD3AE74FC7EDE750E168EF656256974745491FA88A6A8560AA33386992274207BAE4BA4132DD32B4B8D51AA32A1343888206AE757C1A9E79CDDB5301849A19A6122252BEB27D1B82880313C82CEA24712822F265B268D9D46B1311DCBE3ECA0C806E63B98F09D01B40F26D12CB81496299C962D955FA5A858AD3195DB62556060CD9AE0FB7D13EB5A609856A9CCCDD2947BC850110249F355E3772AD5326CD7718618601D18EBD8B418148A1959AA73558364349C12A787987214C3944DA288936E2966606E4C1153C932B9F96012430AEC6869846AE2D0C1BA47497B57014A0DD39ECA8A9FE924AF7AB3BAE957DF84F5664C2AD55A4F97A53E00271A46576E5EBE7BE9E2ED5B57AF5DB88EE222C278D089041A443DA2E1A191448243878C15949158B33BC278B4B382D2ED9E322E1C7CF18B766B66C92DCE7B859C572E7418C154A0F2280E95460498309484ED4C57A02039752AC06B633AFB87406728A732312922F2D62B9EBDD23C78CCDDBB2F17BB9DB08FA421676E229EDDE90E09C948029D05EF513741F85BB3DE46D92B1CB8F99ABBF8ABF56489BDC700FC686FB179B8E2AE6D40677197A9200762F26478312D8955EA06FFB6095539D6455A062A4B116C2E484A00C7CA3721132D1E24D0D5106C983758C2505FCEF3A4F0CFEA1199448156225A844978EA663A1EEB3F61F443BF911CD46CE00E6369C748E4388DD873FB8FBD46CD6331A4688E432C3F984992E496B79DFAB3D6FA4736EC1A9FFC0F334E7D078AE3E55F388DAFAD2D987AF9F6DCD99D87D1E337E6CE87D3313A11D9247E5E0C2D01B787DD80FB1F82854339609A672FB34957FF127512A50DC4F3D7B60A60B736DFA1106BF6E6B6F7B6C8C1616AFF13F938CEF48073AE80B557CE89E4216DC69830E3B01EDE8F85A65D82987BAA02C67F00EC998C50C7060000,
        '2024-06-08 07:12:10', '2024-06-08 07:12:10', 0),
       (454543477039771648,
        '问题2：能否教我用C语言写一个词法分析器中的函数“getNextToken():从输入字符流中获取下一个单词（token）”？',
        0x1F8B08000000000000FF95545D6B1341147D9F5F714DA1D998B5ACF89846A84D85A04D401B3F484BBAEC4E9AA1C96ED8DD342D2510B5B5955A10B455FC427C1011DBF8540A5AFD31CD26F1C9BFE0CCEC4736DBA4E23E0D77EE39F7DC7BCFAC7DF2BCBB71F4E7C7D3F6F1CEEF771F3BAF5AEDE366FBF84BF7B069EFEE755F6F4CF75A07BDCF4D58C25606AF5A73FA32D68418D85B279DBD6FF4BEFD73C73E784609ECC347BD5F2FEC37EF1D82CE87AD5EEB71F7EBA7D3E6039A691FBCEC6CEFF79A9BF6E651FBFB7EE7ED93CEDE3685D322BDD6EE69F321428B8B8B0A1A239A52AEA918264D4B25FA44E96A20A4586B55CC42684CC545A26148A70AB353F7E0B224F9A14C6ED68DF9A11B33F7EF666FA50AD3D95C660EAE2084B55A052CD64A8151C23A02FAA55322438B3095A2A7DBB96B22CCE66E8A904ADF11612693428D04424A49366019AFD5754335F303CC0B7947CE0224613D428A111122F51229637628EA4684E1C3A5CBBABE2C97B0AC261C6AA27A2C0944340B683A45ADE844056C18BA4167EFA8AD1AF4BA2844D2DA8A5CA6B70C2D2B163626E6B5482C811A2EAA225B4A490897C5AB554C93D5028F799CA408822F0892C9701A4F625F2029E48C04CFC16513FBC9AE6E2E29ACC35464AD4054BF2BD632A1A492C3C3C7070231E572B524F7B5C5607C9CE64DBA06F0D09C41CD93789CED2030DA11BAD9CC3CC90DE4A119363A2F459DB881AD9AA1D142A3F5D3D83F1B50C912B18634E0DA35D8012B91A4FE858BFC180FEEE41244A568EC3F1A72E5D33243F5337CAD2A70EB99F9054F06752B15EDB7C2950E789D86E2F181B153EB9896A154AA8229F61F08A194D44752DF3A01516488D011730EFD7ED683C30D3A361A1D69526F36BED3CFBAAA8F75D5F8F61C80857779767952622813378AD7B4F350427DF2E359EF9EB366979F03F9E8D8DA2A32E98FE91C70788217923093BD1EEC6794C061AF9E7D669DD00A20383F8CBF1C83A0D25F060000,
        '2024-06-08 07:13:30', '2024-06-08 07:13:30', 0),
       (454543598594895872,
        '问题3：能否教我用C语言写一个词法分析器中的函数“peekNextToken():查看但不获取输入字符流中的下一个单词”？',
        0x1F8B08000000000000FFC5566B4FDB5618FEEE5F61314DC0C820FD3AD6495B9B4AA81A4C886D9AD66A448E69AC861011B3B65A919C422E4042B2712B97A669B9349B204997160209F063EA736C7FE22FEC3DE7D88EE38469523F2C1FC03EEFED792F7ECF83CE57B4F963942DABF5FD0FCA33B453BCA5978FF4A2A2D68E5029AF2D57D41A3CFFA595149459D3B6E6F5720657D7502A81F339B459849388283E1C161FCB63530FC5304A9EE3B5CA55236DEC28FA410CC5535A2EA1BFD955EB8A7A9AC2CFCB4E7B5083B028BB684B892FBC9251CF77000CC7B52AA742E26349F087787FD81F7A1295A2578D05B0D11AEB7AF97786453B3C64788DE7C7B8F41E02A0D21CAA24F0594EADEF6A8518F8023438950335AD5A47A90DB0C285A45E02D02999A4005E21383B63858120285E35564BE868E3831223A272423B3C806738315EBC369259B04607CF2077A6037F4141ADFD4DBDC5706A1D221B5BAB70C8340D6503654F88662A010F2C28C7350B0041713A090D516B19BD5C47D97570A29E5F6AAB4588823325149FD3DE1508FCB9384ABC576B4B7857C12FF75D52A43458635D9D830643793A348F9471BB44FC0202EA51BF5841F17D96127E1F034B90423C566A980B70EDA81EB8D59534C086C2A3F8B15A5F66462C0B9A261843D920807BDAAEC1B377A65E2C5D35B6386E7C7C5CE03E91C242682620F25F46E58034D51FFCCA7124C84F222239E20606781483365EA0D2967ABA60775A7B5B47F9258EE805C4095E0CCF4CF2BF713CFCC646EEFA867F19BAED1B1E1BBA33E41BF5384E87BFFFF69BD693BBBE9F7E1C19BDED3C1AF9CE37FAF5D8488B9A6FE40E37CBD38CC620E4E0BF00ABAFE0FCBC0D2C2A4FCF08B205CDB2E765EA849C0941FF34FFAB3F3423FE7CC3EBBD3FC8371DD3A6E01DC558BB546B6720259DA21DB4B074C461B6DAFA8A5DBD331BCEDCD0E00F44F916FCEFE93551128F6C6DD4979D03D3C1DE54B77B0B16A49BE1EBB5A74579663A4C620A34E620374B73E83C340C07470F5B556CB44C26B36AD8051582501A139D7E52D52F93DA9F67B8D0407FA471E6B5FE2A6DE11182FCCD6605988747412924F23D52341AF10B628F10ECB5825D67316B07B3170B5917D6C2A1426982B8F4872241BFDBA514967909BC7A07EDA3C094434E7E34C37E3628525FDF7D5027493A553A21A3E89A19F943F0A1D0F04D718B67E2B7FB9EB7DB2D26030B22F7C76556D94A9E2D2F58B539D89B67ADF95B35802F42988CF438A27AF82E69A2AB97BF0915E8ED98764B74F39375E62786A2E2F5CE69F61FE3DF9923DD86CDD6F6F7F7B312CCF2F608D00B84BED9B8A468407A20C9FF5FE39BE13FA6F16C7F0EBA12D62F735AC9FEC2ED9C092AF0D9D7CD3F7DCA9B2F9F3B5F3E73BE0C743B0BE384E675A7EC14DEF84FB8AD95DE5472958CA6616EACA5B6A5D54C95DC031D9284E376F42D0840C35D3673922C4E614F12116DE70D4571E240A90ADBEB6C1753C5993059A300C1C3D3ADDB6B7E8DE68E357722EC263266937EA9E3D20484AEC5CA7046A6C16AA2A78B5C575FF09F063CFC0FA4E0F018BD17EEF23872F4381B625A9B10BC243C5CF71C4749D02210069B0A5C4B5EE01269672BEDD7092186A7C7B8700A4C8910955CDAE6518C9E811A2E670873B3189D3DA8DA11309C056DF5256391E0935DDE406C0895CE2D13E7140CE53F0B206D6F09E148979BB870C246061FBED22B7340EDCCA962F678E398F8AABC65341472833298DA342572CBB10EE796A13CA8A1A0374B26733EC1D5229ECF924BBCB576B0628D177954ABD99C9EDD94F4BA8FAB17DBE8E8403D2D300EC8A82328189BF176F6CFDA6052FDBD79A0FA78FB1DDADB721433CD8AC9C8B0CD964961AB4523B908C58410FF005FA90996860C0000,
        '2024-06-08 07:13:59', '2024-06-08 07:13:59', 0),
       (454543717419528192, '问题4：能否教我用C语言写一个词法分析器中的函数“getTokenValue():获取当前的单词的值或内容”？',
        0x1F8B08000000000000FF8555DF4FD350147EEF5FD1CC6880E0F0D9292F263E119ED41735296E051A6BB7741D620C4987DB188CC1144604C602C27451D68124B09FF0C7D87B5B9EFC173CF7DE6EB675EA1EB6EEDE73CEFDBEEF7CE716ADD7CD76C5DA49FDECAC9A8DDCF5DE27FCB16E3674B3F1D5DAAC3EB0EB35BBAA23A36CAD9D409030236A8FA22F45E5C9949C10878605B4D4C5C513C8B5EB15F66C5F6DA2DD32EA6EA0E53C64A07CD1AED307BD83B35B28934646F387BE884A555C3BB28E5AE665CE6CD4A0024A2ED9C625CEBE37DBC7B8B40CA8000F241230AD5DABBD81CB29BC57B10FAA90C5CAA20F706E1E9F15513683CB05B45D85786BE51CEBC99F9D1D8E130421CCDD9094B09C8888FCBDB81691A2C1D971EF922CBDF0AFA9923243D6B8B1311E193B6673D951C40B822D32289CF6262646C4691EB213618DA72AF16F391E3EE1D92975849F239285789ED4748942232445E3498110F9E30EB04EDBA89CE31658BDD0FF10F9D4F0839A10E745D5034A5262092DC40EB52F37509A5801B70A66FBD0DA4FF6B1C5A2714993A28A039F36171DA5AC420665892FCC6EDEEA1A349C110F27545554A0B22FBCEF08A044D13894B27BE84B0EAD6EF909CC45A5082090341A3C44BF477899FC8CBA290C3BACE8CEED71BAC6DF77E8B9777A4C60F38E67C3411CA46D82DDC9C71313030388A62C7B8162F74106333BA6056BFC9E8E365ADF023F7B2C43C9C1444D8AF36CAA3CFC7A9468C7E9FC152BC160B077EADA0554FCF798714C20EFCC0E3A4215B584AA0C5482B224167835252943C32EF330719F3E072D02B3A22C47F9D751558E049868CC6A326B31B351AF89B79CF6B1C6B1DD1E5346CB3A3E760BE51A148F5AAC905381719D96D4B88B2D60F3B2F7A4C460CEB5E9A1C04392C46BD4B894F45DFE66FC991218F597833CB75ED40270C7701CBBCDD8D0B0DBEC2F3725BB1DCD56461824B6C09812C35C6D13FA7A076AC2684382B56B40AB7D66C3B54338DA375AAC08BB6305D636E774068D5DB1289DED4F1D13DB571B22ADD4392AAC99DD2B7815081EE9FB7C06F58B9C51D23D9903A420971633B10B356A9E936B68A905F039CEAE5FE0B32A4EAD93D74309466B05DE4F64BA7C42FF898B54A3430305F1F703789FA0D5342A7C236A65D204E062F5BAA4DB9F9378BF89F306FC851458C1A78B00CCC935DE018C5F4EEB787222070000,
        '2024-06-08 07:14:27', '2024-06-08 07:14:27', 0),
       (454543820595212288,
        '问题5：能否教我用C语言写一个词法分析器中的函数“advanceToNextLine():将输入指针移动到下一行”？',
        0x1F8B08000000000000FFA554CB4EDB4014DDFB2BA6910A01AAC2BA112BB655D505BB52892818C51275906368A50AC93C9394243C521E4D032A90D0A84D1C8B521AF2FC98CE8C9D557EA1773C89E51A5221358A6C797CEFB9E7DC7B7C4933636EDC909D0AAE17BA8D24AE6E774ECEE971C5FC589CB22A65ABA811FDD44C1BC1B9E5A01C12A7232FC477EA734916FD2324D6A4078699DD30F335DCDAFEADAD915C9196F3FC1157CB8047E37BB85E22AB314B6F59AD0CD92C0036291F93B52204E3AA86ABDF48F9C82C5D32A8FA066401203FC1D52BC01484D9D9D990303E8EC885418FD3BCAAB01C91E6D05D52A17050194592BCB8A43E819B3A8A424B8A22CAEACB485452A5883C12106C2C3D8B6F13FF8B85DE0B087E80677EBE2671A3B31A83EBF08C3C4CE38796B6090F56ABE5A8A1B9EFC468D9296FC3D28288FC36F8AB510FEEEB47938881A0A121F4AF8889E13E833E8BAF75F2A10855618CEEDE3A317E2FD0C8D858C07EBB625FFB72C8E51A3DCDD1AB339A4B0C1621CD0F548026B9840712EC36E2D6AF1FCEB97596642E6868247FDD6D241E447F85F944106C57D5F960C14CB8D90627DF63DE6E23DB73164C16BD094AB2BFCF95CDBDD777D0817CD361298AE0AF8645342F2951152D00C4D319D9FD222A8622F21C7FE3E39C18B0872FC04D04FEEAB447B67D7C976ECF844377CDECC682CF14E47B6268324676F7706DCB2C95702DE96EAD9DB7A800CF79BF6F8AA7D90A9EA1C7511F94E34DF0CED65D5511D5254566A27AFDB7DA9FA8FE13D72FCC2FAB9DCB43B219E79F2D1018B842604FB01DB49BBE77789049F475D80403F369BA40768EB89FB85CBE6A1CCF826238EFECC7C97ED21D469A199248E166CA6CEA2CE6E09AA1D9916C9BE9EB1D2D6BB563DCB59E36B84D4C53E7ACAFB0C44E0A7C5D1263ABB7EE6C348FEF2118F0694E03CD20DE23DB599B03CD0B651C4467AC0CE8F686263224659058CDAA1478993F9FE0ADCAE2050000,
        '2024-06-08 07:14:52', '2024-06-08 07:14:52', 0),
       (454543926342004736,
        '问题6：能否教我用C语言写一个词法分析器中的函数“skipWhitespace():跳过空白字符，如空格，制表符，换行符等”？',
        0x1F8B08000000000000FF7D545B53D340187DCFAFD8D1715A66507846F1C5D1BFE00B0FE984683342CAB4419C1167C2B545E8C56929D29B80B656EC2578694BD3CB7FC1EC6EFAC45FF0DB6C5B6A41F2B4D9EC77CEF9CE7736B81DA79B351CAD5A66FEB2B58733C52776B56C1775AB518677AB018B535AD171789FA63671254723C6859E09BC52969E7B154D0E2C7924D93D71A16771B04DF60D8E8437A25663B7973DB1BB87E4A87ED94A0982288A92705751A585E579193D0A68F38AEF81F7B1204C4D215C4959E73B9C8CE300374D1449366FD77FDADD20FDD6A4876D5C3EA0A582F0DAA7CCA37105E8AD80E051540D490F05670DC056BB0B302F654DF27AFCEE098E6D9911BB13C75B79E8D1AE9A389AEC337378562AA15934ACBA82C39D531AA9D2F42F1C3278252C7AD9DC3FF2D8D915AFB2202337C0CCBA5C68759501CE22D79C36FAA2BA06AA6FA0645BEF86C424A3E35884CB1CE3EB6574BBB0D60B8649D220890E4EE786CD39D5CB2A43754B938859AE0234C0329B163D8A3AF48DD10E8D5BF2C3F717EE3B4F554DF6A3806F51469AFC46432B8AE665ADF54D9F9953EF8C9873C3A4D897F1418D14380ED252E9C6BEFE3B8781BA678A3FA021D5A7DEBF92E4F4E19140F60CBA2781BE49240DEAFCB2B6EC57D1343300C228081076C827305BE6677AB4C613CF23228EAB167992ACE6B638D423F2B32CA4D752F4475F67F72A166190950DBB9B7646E21C7042C4F6DBF16188A07372D4629BA19A7D5C0404124A92F0897DBCC7D60735F6C938B31A30E632CE1803C6DD31521E144E8A8DEDD1DCF4ED4E6D8E07C8898EDD4D407458AE07E961D7DFCC5B9D2E2050B3CCAE7F689BE462F8B0387AD7872D002308706C1579B6FA06712C12FA609925D24AD02F4DB01117D6ADF63E77F5BADBBC10E07A8524DE0AF17EC8C70EAF857E48E5374906A1017C5E83F893B375F6BB08D507EA75AB99C67B5B38F69D3B0BEAE13CC994C607636CDC2260F4FFD31F0FD0DD1ADBEB33B89A3138E89C213B711C36608744BEC2BC71142C7AEF780739A1C55D5CFF41CD38C97E9AECE93A0E36793EA785BF91DAAF8FAD050000,
        '2024-06-08 07:15:17', '2024-06-08 07:15:17', 0),
       (454544016020418560,
        '问题7：能否教我用C语言写一个词法分析器中的函数“isIdentifier(token):判断一个单词是否是标识符”？',
        0x1F8B08000000000000FF8D54CB4EDB4014DDFB2BA6A92A920201BAA554AA58B1E907B420B012878C080EB28D2A5A900CA4E0343CD2F22A101E2D84A62869102A25CA837C0C9EB1B3CA2FF4DA438C13A0228B683C73CF3DE7DE997B4865CD88FD25AB79BD94BE56E7482AD36FE6736646D50B39A3BC4916B6F502AC4FC962856E9C61792028880A0E6141F22AD13141F4D1BD343D52E941FA262EB765644FF4C239FD9627495814E9E1A2995F80CD7A7989F1D4662FC8D5292CF44282E6D2B5D3E37A7987E37AFCC889357662E6CF18D1B6AD1384502762E99D00400315CD2FD7CB1ADFF9E15A9D7DDDF9B65E8E536D13B212EDAB51ACC2D1306C91B24A8EFF40712C1149AED4F67E3025E6E501CB027828CF5ABBF016847BE147AC0F773B60AB1E191909704FB118884C0605F452568238EA0FBF726D0594A90901B65057170A452584653E3211E6BDBE0E5806F12856BC3E8EC3A2829ADA1B08F3127ACE9A8C3E5ADA911D83FA50772F677F43C2FEB01018433884425892156481F88022582C88471141B1D6403A290605490E442581650A21EF136F43894DF20E0FF9D0F4346A7CA0BE3ED436DCE66B905B3F4950262511F82DEA375105F122C28E643B6CA6459A248CF358C4E2E8AD36D98E781FC61101DD70B7B7E3A127C037D8DDE6E6FB8FCC46EB1EADFD91FA590DAE4A6E303D36664069935B4033ECEEAC2ABD0D3EFBEE9818D0823CE353B717EBE9756EE09E71722B9E902071C8EB7926DBB7E966F50F8A9E0EC6E063F9669010918507D1626BB1F764E09A5A0485C1DBE638B004BDF019460666522F1D1987B3600D30CB6EF16C36E84A9AAC6EB97D00368D520CE6D0652A3B31C7236038F54A0A3C82ACCE41A8E53FBFE76B279BE493C63CC5C8669BD2353C850D6DF3AC2F593E965C614012FF05470E570BF0A169272773743F45E32A4DC519B0365F817F92D41A6E744FD966759DECEEF7C099F93D631C17CD7CDAED822DC6659B0AF4D47A2F0CCFDA49B52F7A29AB57AAC67A462F2E401EFD2AE1A0DC0FC872DC8B8499DFB82BC5A9C1D2D0220EE4D3F81A593E238B96442735488472E98606DD6A566956778D4C825C9E1BA535BA77D0515355C0B237D0CDFD03D4F9796F3A060000,
        '2024-06-08 07:15:39', '2024-06-08 07:15:39', 0),
       (454544129493118976,
        '问题8：能否教我用C语言写一个词法分析器中的函数“isOperator(token):判断一个单词是否是操作符”？',
        0x1F8B08000000000000FF8553CB6EDA4014DDFB2B46541106DAC09ED04D3FA01F902241C13456A91D19B3AA2291883CAA04420569534269D21684A280A34A8DCC2B7C4C67C666955FE81D1B063741E92C78DC9973E69C7BEE9071D52ADE9063030F5B77A3236C1E4EBF7EA7A78655EBBCB08DAEDD29905ED32A5F5BF5A29C7BB92969495DD5C8FE989E5CDF8DEA8290482452C213594965F36909ADE5F4B4ACAE6E3CFFA7A4C9CA9BFBB5F46B55CDB2A2C07EA005B798DA486A4857DF4ACA7A3C80DE0B0856388C48AF8EFB1FB059B086455A2DE171C3BA6A3B9B0E409DC173EB711443BED0B3607825E68B0A1C7E7B69958DE9768994F7381C4C001BD826ED1DDA6C3897924687EF63B34BBAA7508123F6A446CE9ABA96971CCA8CAA2151567424C37591287CAD21709A9514914B094039149A7B604BCE20D1B5160199318F6A39EE3DC79626E9794D41ECC628DFD812DC4F6E6B211C9BA5C7B56792D99C2B7E46ED14A202B03123EF92B222CE45784360FD0CFA5C0DCC80272BE744C0AB7C13C2D633A2CFBF92F343AA28A97093ABAF14DF539734E0B26D2109143C825654FD3F0C82D750849981891404F06D4FBE60F3D21D556806B4811E7CC4C3AB69FB13D93D988DD360EFDE44C19C93EE67A77FBFFE1476D8DBA8943916683921FD51A0DF5A78744E765B807254C1C32195F6D21880CC0D8BA7E2522EE68A0575D1B17E0E5CE573421008FF3821E761792FA372525DC60580A5744EB758FA0F7B457F1FDAC60974E9E1DB3FB26FABE01CF6FC413F706173E0DCC25E53FF869EF769A9E79E756559C32A8866A0FD0180AC33930C6AD0377A5C0199787241B70D26E62F2B1C651B91040000,
        '2024-06-08 07:16:06', '2024-06-08 07:16:06', 0),
       (454544251266347008,
        '问题10：能否教我用C语言写一个词法分析器中的函数“addError(message):将错误信息记录到日志或错误处理器中”？',
        0x1F8B08000000000000FF7592516FD25014C7DFFB299A1993B92C7E018D2FC64FA1269750E648149682BE1893D220656358740C0467D26D804407458D0CD6967E18EF392D4F7C054FB97462E2FAD0E4DE7BCEEFFCCFFF1CF08E82E2184C9B3BDDDF9A4E7F3EA9E0473BA8F71F86F620EC6B81DB80522B68175942511EA96A56656078783C0A3A577C56A12438E9E3A0238E7C3258B887587ECF9D0BEEF984613B7B6A3A93DF5965C1A834AFB742DBE6FE29166C42C3DB2E9447681960AC9EF05781E5F24A4A5519F1A8822431C692D2AD7426F9FCA59292EFD36B3A7B77F78124BDCAA6153956B699CC66727939B99B50E5AD17A95C2EF12C75477E2DC9F4AD646C0AF0B6BCF17899F254BE9D7B92D9D896E3F07BD29BA89A24857E8B4FBE5EAB66AB0006A61E75DF2E82E6A2F941C867EB3406558B7BD5E0A227EC881CAEBD23065A2EB8261C36E8180106CD65CC0FE142DCF3B261329592B16108C43F6296D3A21BB42EC32FE773E360E1B66902FF3578E19629F86F25EF8C14A059E3B34F0B771F2F1D38B048BF48814E31A895A0D517B6930651777DB6EBF0F0ECDB4D031404D4FB422D5A53AC0EE7275AD82B707F88F5E9B5E0E8D5390DC73F29984C09F6A7306C53247ED7A38D9C55A0A7473B15A36EDA203ED1486AE498338ED7B02176109B5DF09B7075849FBBE17004DEF13A81AAFC01CE530EA107030000,
        '2024-06-08 07:16:35', '2024-06-08 07:16:35', 0);
